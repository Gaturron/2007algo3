\item $prepararArregloEstanImagenes(int im)$

inicializa un arreglo en false//
Costo $O(im)$

\item $intervalosElementales(Lista(imagenes) img) -> Conj(puntos):res$

\begin{framed}
\begin{verbatimtab}[4]
intervalosElementales(Lista(imagenes) img) -> Conj(puntos):res
{
	desde 0 a Tam(img) hacer		// O(1) / itera im veces
	{
		res <- agregar(x_0)		// O(log(2im))
		res <- agregar(x_1)		// O(log(2im))
	}
	return res				// O(1)
}
\end{verbatimtab}
\end{framed}

Como ingresamos dos puntos por imagen a lo sumo el conjunto tendra $2im$, por lo que pudimos acotar la insercion $log(2im)$.\\
El costo total de este algoritmo es pues $O(im*log(im))$




            
$insertar(IntervaloElemental ie) $
            
$insertarImagen(int indexOf, int inicio, int finaL, int min, int max, Nodo<IntervaloElemental> actual) $
      
      
\begin{framed}
\begin{verbatimtab}[4]
insertarImagenes(Lista(Imagen):imagenes, bool:X)
{
	depeniendo de si es por X o por Y
		por cada imagnen de "imagenes"
			insertarImagen(i, inicio, fin, 0, ANCHO_ARBOL, raiz);
}
\end{verbatimtab}
\end{framed}

\begin{framed}
\begin{verbatimtab}[4]          
llenarArbol( Lista(Imagen):imagenes, bool:X) -> ArbolDeIntervalos
{
	prepararArregloEstanImagenes(im);
	llenarIntervalosElementales(imagenes, X);
	insertarImagenes(imagenes, X);
}
\end{verbatimtab}
\end{framed}

\begin{framed}
\begin{verbatimtab}[4]          
llenarIntervalosElementales(Lista(Imagen):imagenes, bool:X)
{
	Conj(IntervaloElemental):puntos = intervalosElementales(imagenes, X);

	por cada imagnen de "imagenes"
		insertar(elemento)
}
\end{verbatimtab}
\end{framed}

	

% buscarIndices(int x, Nodo<IntervaloElemental> actual, java.util.List<java.lang.Integer> res) 
            
% busqueda(int x, int y, java.util.List<Imagen> Imagenes_levantadas, boolean X) 



